# More info about libs available in requirements.txt
# Pressing F5 will run the app and open the browser with the swagger UI

from apiflask import APIFlask, Schema, abort
from apiflask.fields import Integer, String, DateTime
from apiflask.validators import Length, OneOf
from flask_cors import CORS
import flask
import psycopg
import os
import logging


app = APIFlask(
        __name__, title="Medical API", version="1.0", spec_path="/openapi/docs"
    )
app.config["SYNC_LOCAL_SPEC"] = True
app.config["LOCAL_SPEC_PATH"] = "/doc/medical.json"

CORS(app)

app.logger.setLevel(logging.DEBUG)
app.logger.info("Init the application.")


# Defining object get and sent by the api
class MedicalTreatmentOut(Schema):
    id = Integer()
    Description = String()
    Citizen = String()
    LeadDoctor = String()
    startdate = DateTime()


class MedicalTreatmentIn(Schema):
    # id = fields.Integer() -> Generated by the database
    Description = String()
    Citizen = String()
    LeadDoctor = String()
    startdate = DateTime()


@app.get("/")
@app.output(MedicalTreatmentOut(many=True))
def index():
    conn = get_database_connection()
    user_uuid = flask.request.headers.get("X-Claim-Subject")
    
    cur = conn.cursor()
    cur.execute(
        """
        SELECT m.startdate, m.description, d.name, d.firstname, d.address, d.category
        FROM medicaltreatment AS m
        JOIN doctor AS d on m.leaddoctor = d.inaminumber
        WHERE citizen = %s;
    """,
        (user_uuid,),
    )
    rows = cur.fetchall()
    
    if (len(rows) < 1):
        return flask.jsonify({'error': {
            'code': 404,
            'message': 'No rows'
        }})

    response_object = {'data': []}

    
    for row in rows:
        date, description, name, firstname, address, category = row
        data_object = {
            'date': date,
            'description': description,
            'doctor': {
                'name': name,
                'firstname': firstname,
                'address': address,
                'category': category   
            }
        }
        response_object['data'].append(data_object)    
    
    
    # print(rows)
    # column_names = [desc[0] for desc in cur.description]
    # # Construct a list of dictionaries
    # content = []
    # for row in rows:
    #     content.append(dict(zip(column_names, row)))
    # return flask.jsonify(content)
    return flask.jsonify(response_object)

@app.post("/")
@app.input(MedicalTreatmentIn)
def post_medical():
    conn = get_database_connection
    conn.cursor().execute(
        """
                            INSERT INTO medicaltreatment (Description, Citizen, LeadDoctor,startdate)
                            VALUES ('%s','%s','%s','%s','%s');
                            """,
        (
            flask.request.json["Description"],
            flask.request.json["Citizen"],
            flask.request.json["LeadDoctor"],
            flask.request.json["startdate"],
        ),
    )
    conn.commit()
    return "201 - Medical treatment created"



# This is a full access of a folder: it should be logged in the system
@app.get('/<int:id>')
@app.output(MedicalTreatmentOut(many=False))
def get_medical(id):
    #get the content from the database /!\ SQL Injection
    id = flask.request.args.get('id')
    #extracted from the JWT token by kong
    user_uuid = flask.request.headers.get("X-Claim-Subject")
    #Obtain get_connection
    conn = get_database_connection()
    curr = conn.cursor()
    curr.execute("""
                            SELECT * FROM medicaltreatment
                            WHERE id = %s AND citizen = '%s';
                            """, (id, user_uuid))
    #get the content from cursor in json format
    rows = curr.fetchall()
    column_names = [desc[0] for desc in curr.description]
    # Construct a list of dictionaries
    content = []
    for row in rows:
        content.append(dict(zip(column_names, row)))
    #Log in the db the access using an insert
    conn.cursor().execute("""
                            INSERT INTO accesslog (MedicalTreatmentUniqueId, Citizen, AccessDate)
                            VALUES ('%s','%s',CURRENT_TIMESTAMP);
                            """,(id, user_uuid))
    #The postgresql instance generate the timestamp
    conn.commit()
    return flask.jsonify(content)


class DatabaseConnection:
    # Singleton pattern
    # A timer to deconnect the database after a certain time could be added
    _instance = None

    def __new__(cls, app):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.connect(app)
        return cls._instance

    def connect(self, app):
        # Extract from environment variable information to connect to the database
        pg_user = os.getenv("POSTGRES_USER", "postgres")
        pg_password = os.getenv("POSTGRES_PASSWORD", "jadoreleprojetintegreetmonsieurcharlet")
        pg_host = os.getenv("POSTGRES_HOST", "128.199.52.52")
        pg_port = os.getenv("POSTGRES_PORT", "5432")
        pg_db = os.getenv("POSTGRES_DB", "bdservices")
        # Display a Warning if the default values are used
        if (
            pg_user == "postgres"
            and pg_password == "postgres"
            and pg_host == "localhost"
            and pg_port == "5432"
            and pg_db == "test"
        ):
            app.logger.info("Warning: Using default values for database connection")

        # Connect to the database
        app.logger.info(
            f"Connecting to database {pg_db} on {pg_host}:{pg_port} as {pg_user}"
        )
        # Based on key values present there  https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING-KEYWORD-VALUE
        self.conn = psycopg.connect(
            user=pg_user, password=pg_password, host=pg_host, port=pg_port, dbname=pg_db
        )

    def get_connection(self):
        return self.conn

def get_database_connection():
    db = DatabaseConnection(app)
    return db.get_connection()



if __name__ == "__main__":
    from gunicorn.main import run  # Assuming Gunicorn is installed
    run(app, "0.0.0.0:5000", workers=4)  # Run Gunicorn with the app instance
